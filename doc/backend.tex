Основной задачей кодогенератора является преобразование
переданного ему Абстрактного Синтаксического Дерева в
набор машинных инструкций, которые в дальнейшем можно интерепретировать
тем или иным способом.

Рассмотрим более подробно методы, которые были использованы при написании генератора кода.

\subsection{Low Level Virtual Machine}

LLVM -- это универсальная система анализа, трансформации и оптимизации программ или, как её называют разработчики, <<compiler
infrastucture>>.

В основе LLVM лежит промежуточное представление кода (intermediate representation, IR), над которым можно производить
трансформации во время компиляции, компоновки (linking) и выполнения. Из этого представления генерируется оптимизированный
машинный код для целого ряда платформ, как статически, так и динамически (JIT-компиляция). LLVM поддерживает генерацию кода для
x86, x86-64, ARM, PowerPC, SPARC, MIPS, IA-64, Alpha.

\subsubsection{Типы данных}

В LLVM поддерживаются следующие примитивные типы:
\begin{itemize}
    \item Целые числа произвольной разрядности:
        \begin{itemize}
            \item \icode{i1} -- булево значение — 0 или 1
            \item \icode{i32} -- 32х разрядное целое
            \item \icode{i17} -- даже так
            \item \icode{i256} -- и так
        \end{itemize}
    \item Числа с плавающей точкой
    \item void — пустое значение
\end{itemize}

Кроме того поддержимаются производные типы, как например
\begin{itemize}
    \item \icode{i32*} -- указатель на целое число;
    \item \icode{[8 x double]} -- массив из восьми чисел с плавающей точкой;
    \item \icode{\{ i1 i10 i32 \}} -- структура из 3х элементов;
    \item \icode{i32 (i32, i32)} -- функции;
\end{itemize}

Система типов рекурсивна, поэтому можно использовать многомерные массивы, массивы структур, указатели на структуры и функции, и т.
д.

В виду специфики языка MiniML переменные ограничиваются
только двумя типами: 32х разрядное целое знаковое число (\icode{i32}) и
булево значение (\icode{i1}).

\subsubsection{Операции}

Большинство инструкций в LLVM принимают два аргумента (операнда) и возвращают одно значение (трёхадресный код). Значения
определяются текстовым идентификатором. Локальные значения обозначаются префиксом \icode{\%}, а глобальные — \icode{@}. Локальные значения также
называют регистрами, а LLVM — виртуальной машиной с бесконечным числом регистров. Пример
представлен в листинге \ref{lst:llvm_bytecode_example}.

\lstset{escapeinside={(*@}{@*)}}
\begin{lstlisting}[caption=Пример сгенерированного LLVM байткода
                  , label=lst:llvm_bytecode_example]
; ModuleID = 'MiniML'

; factorial function
define i32 @f(i32 %n) #0 {
entry:
  %0 = icmp eq i32 %n, 0
  br i1 %0, label %if.exit, label %if.else

if.else:                                          ; preds = %entry, %if.else
  ; %z = sum i32 %x, %y (*@\label{lst:comment_z1}@*)
  ; %z = sum i32 %z, 5 (*@\label{lst:comment_z2}@*)
  %n.tr2 = phi i32 [ %1, %if.else ], [ %n, %entry ]
  %accumulator.tr1 = phi i32 [ %2, %if.else ], [ 1, %entry ] (*@\label{lst:phi_fun}@*)
  %1 = add i32 %n.tr2, -1
  %2 = mul i32 %accumulator.tr1, %n.tr2
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %if.exit, label %if.else

if.exit:                                          ; preds = %if.else, %entry
  %accumulator.tr.lcssa = phi i32 [ 1, %entry ], [ %2, %if.else ]
  ret i32 %accumulator.tr.lcssa
}

; Function Attrs: nounwind readnone
define i32 @fact(i32 %n) #0 {
entry:
  %0 = tail call i32 @f(i32 %n)
  ret i32 %0
}

; Function Attrs: nounwind readnone
define i32 @main() #0 { (*@\label{lst:main_fun}@*)
entry:
  %0 = tail call i32 @fact(i32 10)
  ret i32 %0
}
\end{lstlisting}

Тип операндов всегда указывается явно, и однозначно определяет тип результата.
Операнды арифметических инструкций должны иметь одинаковый тип, но сами инструкции <<перегружены>> для любых числовых типов и векторов.

Рассмотри более подробно особенности интерпретируемого LLVM байткода.

\subsubsection{Static Single Assignment form}

Static Single Assignment form (далее SSA) -- это такая форма промежуточного представления кода,
в которой любое значение присваивается только один раз. Таким образом, последовательность инструкций
в строках \ref{lst:comment_z1} -- \ref{lst:comment_z2} листинга \ref{lst:llvm_bytecode_example} неверна
и привидет к ошибкам компиляции. Новое значение переменной обязательно долно принять новое имя.

Код в SSA-форме удобно рассматривать не как линейную последовательность инструкций,
а как граф потока управления (control flow graph, CFG). Вершины этого графа -- так
называемые базовые блоки (basic blocks), содержащие последовательность инструкций,
заканчивающуюся инструкцией-терминатором, явно передающей управление в другой блок.
Базовые блоки в LLVM обозначаются метками, а терминаторами являются следующие инструкции:
\begin{itemize}
    \item \icode{ret тип значение} -- возврат значения из функции;
    \item \icode{br i1 условие, label метка\_1, label метка\_2} — условный переход;
    \item \icode{switch} -- обобщение br, позволяет организовать таблицу переходов:\\
        \icode{switch i32 \%n, label \%Default, [i32 0, label \%IfZero i32 5, label \%IfFive]};
    \item \icode{invoke} и \icode{unwind} -- используются для организации исключений;
    \item \icode{unreachable} -- специальная инструкция, показывающая компилятору, что выполнение никогда не достигнет этой точки.
    \item инструкция $\varphi$ -- специальная инструкция, которая возвращает одно из перечисленных значений в зависимости от того,
        какой блок передал управление текущему.
\end{itemize}

В LLVM функции $\varphi$ соответствует инструкция $\phi$, которая имеет следующую форму:
\begin{verbatim}
phi тип, [значение_1, label метка_1], ..., [значение_N, label метка_N]
\end{verbatim}

Пример использования этой функции можно увидеть в строке \ref{lst:phi_fun} листинга \ref{lst:llvm_bytecode_example},
где приводится код функции вычисления факториала числа.

\subsubsection{Память}

Помимо значений-регистров, в LLVM есть и работа с памятью. Значения в памяти адресуются типизированными указателями.
Обратиться к памяти можно только с помощью двух инструкций, названия которых говорят сами за себя: \icode{load} и \icode{store}.

Но чтобы пользоваться указателями, надо как-то выделять память под значения, на которые они указывают.
Инструкция \icode{malloc} транслируется в вызов одноименной системной функции и выделяет память на куче, возвращая значение -- указатель
определенного типа. В паре с ней идёт инструкция \icode{free}.

Для выделения памяти на стеке служит функции \icode{alloca}.
Память, выделенная этой функцией автоматически освобождается при выходе из функции при помощи инструкций \icode{ret} или \icode{unwind}.

\subsubsection{Оптимизации}

LLVM имеет встроенный оптимизатор кода, которые способен выполнять следующие оптимизации кода:
\begin{itemize}
    \item Удаление неиспользуемого кода (dead code elimination).
    \item Выделение одинаковых подвыражений (common subexpression elimination).
    \item Распространение констант (constant propagation, condition propagation).
    \item Инлайн-подстановка функций.
    \item Раскрутка и размыкание циклов, вынос инвариантов за пределы цикла.
    \item Разворот хвостовой рекурсии.
\end{itemize}

Преобразование может быть не только оптимизирующим, но и использоваться для анализа и инструментации. Например, LLVM может
генерировать CFG в формате Graphviz \cite{graphviz}.

\subsubsection{JIT компиляция}

Для вывода результата выражения была использована технология Just-in-time compilation (JIT компиляция) --
технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или
в другой формат непосредственно во время работы программы.

В случае, если требуется вычислить выражение любой сложности,
формируется функция \icode{main} (строка \ref{lst:main_fun}, листинг \ref{lst:llvm_bytecode_example}),
которая подается вместе с остальным кодом компилятору.

В результате значением исходного выражения окажется значение, которые вернула функция \icode{main}.
Более подробно ознакомиться с кодом компиляции LLVM байткода можно в приложении 6.

\subsection{Особенности реализации}

При реализации генератора кода было встретилось множество проблем, связанных с особенностями языка
MiniML.
Рассмотрим некоторые из них.

\subsubsection{Глобальные переменные}

Рассмотрим в листинге \ref{lst:global_var_miniml} пример кода на языке MiniML.
\begin{lstlisting}[caption=Создание глабальной переменной
                  , label=lst:global_var_miniml]
MiniML> let a = 2 + 3 + fact(4) * 3 - 456
MiniML> a
- : int = -379
\end{lstlisting}

Данное в листинге \ref{lst:global_var_miniml} выражение безусловно является сложным. При его вычислении требуется вызвать рекурсивную
функцию вычисления факториала числа, и провести некоторые математические операции с результатом.

Данное выражение требует дважды вызвать интерпретатор LLVM байткода.
Первый раз это необходимо для того, чтобы вычислить правую часть выражения,
а во второй раз -- чтобы создать глобальную переменную \icode{@a} и присвоить ей значение,
вычисленное при первом проходе.

В виду простоты языка MiniML было решено избежать повторного вызова интерпретатора.
Данное решение отличается от предыдущего более простой, но более ресурсоемкой реализацией.

Рассмотрим более подробно схему, используемую в данном случае.

\begin{lstlisting}[caption=Пример сгенерированного LLVM байткода для глобальной переменной
                  , label=lst:global_var]
define i32 @a_global(i1 %_) #0 {
entry:
  %0 = tail call i32 @fact(i32 4)
  %1 = mul i32 %0, -3
  %2 = add i32 %1, -451
  ret i32 %2
}

define i32 @main() #0 {
entry:
  %0 = tail call i32 @a_global(i1 undef)
  ret i32 %0
}
\end{lstlisting}

В листинге \ref{lst:global_var} представлен оптимизированный код для выражения из листинга \ref{lst:global_var_miniml}.
Видно, что вместо создания глобальной переменной \icode{@a} была создана функция \icode{@a\_global},
которая вызывается всякий раз при обращении к переменной.

\begin{lstlisting}[ language=haskell
                  , caption=Реализация глобалой переменной в программе
                  , label=lst:lexical_error]
codegenTop :: TC.Ctx -> Vars -> S.ToplevelCmd -> LLVM ()
codegenTop _ globVars (S.Def var_name (S.Fun name argname argtype rettype body)) = do
  define (toType rettype) name fnargs bls
  define (toType rettype) var_name var_args var_bls
  modify $ \s -> s { ty = rettype }
  where
    (fnargs, bls) = genFun globVars (S.Fun name argname argtype rettype body)
    (var_args, var_bls) = genFun globVars (S.Fun var_name argname argtype rettype pseudo_body)
    pseudo_body = (S.Apply (S.Var name) (S.Var argname))
\end{lstlisting}

С точки зрения вычислений это однозначно является не самым удачным решением, однако язык MiniML использован
исключительно в демонстрационных целях и данное решение вполне является оправданным.

Более подробно с кодом можно ознакомиться в приложениях 4 и 5.

\subsubsection{Переменные, хронящие ссылки на функции}

Аналогичным способу, указанному в листинге \ref{lst:global_var}, образом была
реализована геренация глобальных переменных, ссылающихся на функции.

\begin{lstlisting}[caption=Пример сгенерированного LLVM байткода для глобальной переменной
                  , label=lst:func_var]
MiniML> let b = fun f (x:bool):int is if x then 10 else 20

define i32 @f(i1 %x) #0 {
entry:
  %. = select i1 %x, i32 10, i32 20
  ret i32 %.
}

define i32 @b(i1 %x) #0 {
entry:
  %0 = tail call i32 @f(i1 %x)
  ret i32 %0
}
\end{lstlisting}

Из листинга \ref{lst:func_var} видно, что вместо того, чтобы сделать одну функцию \icode{@f} и
переменную, которая хранить ссылку на функцию,
было принято решение сделать 2 функции (\icode{@f} и \icode{@b}), одна из которых вызывает другую.

Таким образом, при обращении к переменной \icode{b} в действительности приосходит вызов
функции \icode{@b}, которая в свою очередь передает управление функции \icode{@f}.

\subsubsection{Перекрытие переменных}

Для упрощения логики построения байт кода перекрытие переменных было реализовано следующим образом.
Вместо того, чтобы хранить весь код в виде последовательности АСТ деревьев и при каждом
вызове интерпретатора снова и снова генерировать код занова, в памяти хранится
лишь список глобальных переменных и уже частично сгенерированный код.

\begin{lstlisting}[caption=Пример перекрытия переменной \icode{a} новым значением
                  , label=lst:again_vars]
MiniML> let a = 1

define i32 @a_global(i1 %_) #0 {
entry:
  ret i32 1
}

MiniML> let a = 2

define i32 @a_global(i1 %_) #0 {
entry:
  ret i32 1
}

define i32 @a_2_global(i1 %_) #0 {
entry:
  ret i32 2
}

\end{lstlisting}

Таким образом, при попытке перекрыть переменную, вместо того, чтобы
убрать из генерируемого кода старую переменную (если точнее, функцию)
проиходит лишь создание новой функции с новым именем. Старая функция останется в памяти, однако при исполнении
она будет удалена из конечной программы на проходе оптимизатора (листинг \ref{lst:again_vars}).

При обращении к переменной во второй раз уже будет вызвана новая функция с новым значением.
